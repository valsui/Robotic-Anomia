{"version":3,"sources":["../src/cross-validate.js"],"names":["testPartition","shuffleArray","crossValidate","Classifier","opts","trainOpts","trainSet","testSet","classifier","beginTrain","Date","now","trainingStats","train","beginTest","testStats","test","endTest","stats","Object","assign","trainTime","testTime","iterations","trainError","error","learningRate","hidden","hiddenSizes","network","toJSON","array","i","length","j","Math","floor","random","temp","data","k","size","constructor","Array","newData","keys","forEach","key","avgs","truePos","trueNeg","falsePos","falseNeg","total","misclasses","results","stat","sum","dclone","slice","splice","result","concat","push","precision","recall","accuracy","testSize","trainSize","sets"],"mappings":"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","file":"cross-validate.js","sourcesContent":["/**\n *\n * @param {NeuralNetwork|constructor} Classifier\n * @param {object} opts\n * @param {object} trainOpts\n * @param {object} trainSet\n * @param {object} testSet\n * @returns {void|*}\n */\nexport function testPartition(Classifier, opts, trainOpts, trainSet, testSet) {\n  let classifier = new Classifier(opts);\n  let beginTrain = Date.now();\n  let trainingStats = classifier.train(trainSet, trainOpts);\n  let beginTest = Date.now();\n  let testStats = classifier.test(testSet);\n  let endTest = Date.now();\n  let stats = Object.assign({}, testStats, {\n    trainTime : beginTest - beginTrain,\n    testTime : endTest - beginTest,\n    iterations: trainingStats.iterations,\n    trainError: trainingStats.error,\n    learningRate: trainOpts.learningRate,\n    hidden: classifier.hiddenSizes,\n    network: classifier.toJSON()\n  });\n\n  return stats;\n}\n\n/**\n * Randomize array element order in-place.\n * Using Durstenfeld shuffle algorithm.\n * source: http://stackoverflow.com/a/12646864/1324039\n */\nexport function shuffleArray(array) {\n  for (let i = array.length - 1; i > 0; i--) {\n    let j = Math.floor(Math.random() * (i + 1));\n    let temp = array[i];\n    array[i] = array[j];\n    array[j] = temp;\n  }\n  return array;\n}\n\n/**\n *\n * @param {NeuralNetwork|constructor} Classifier\n * @param {object} data\n * @param {object} opts\n * @param {object} trainOpts\n * @param {number} k\n * @returns {\n *  {\n *    avgs: {\n *      error: number,\n *      trainTime: number,\n *      testTime: number,\n *      iterations: number,\n *      trainError: number\n *    },\n *    stats: {\n *      truePos: number,\n *      trueNeg: number,\n *      falsePos: number,\n *      falseNeg: number,\n *      total: number\n *    },\n *    sets: Array,\n *    misclasses: Array\n *  }\n * }\n */\nexport default function crossValidate(Classifier, data, opts, trainOpts, k) {\n  k = k || 4;\n  let size = data.length / k;\n\n  if (data.constructor === Array) {\n    shuffleArray(data);\n  } else {\n    let newData = {};\n    shuffleArray(Object.keys(data)).forEach((key) => {\n      newData[key] = data[key];\n    });\n    data = newData;\n  }\n\n  let avgs = {\n    error : 0,\n    trainTime : 0,\n    testTime : 0,\n    iterations: 0,\n    trainError: 0\n  };\n\n  let stats = {\n    truePos: 0,\n    trueNeg: 0,\n    falsePos: 0,\n    falseNeg: 0,\n    total: 0\n  };\n\n  let misclasses = [];\n  let results = [];\n  let stat;\n  let sum;\n\n  for (let i = 0; i < k; i++) {\n    let dclone = data.slice(0);\n    let testSet = dclone.splice(i * size, size);\n    let trainSet = dclone;\n    let result = testPartition(Classifier, opts, trainOpts, trainSet, testSet);\n    for (stat in avgs) {\n      if (stat in avgs) {\n        sum = avgs[stat];\n        avgs[stat] = sum + result[stat];\n      }\n    }\n\n    for (stat in stats) {\n      if (stat in stats) {\n        sum = stats[stat];\n        stats[stat] = sum + result[stat];\n      }\n    }\n\n    misclasses.concat(results.misclasses);\n\n    results.push(result);\n  }\n\n  for (stat in avgs) {\n    if (stat in avgs) {\n      sum = avgs[stat];\n      avgs[stat] = sum / k;\n    }\n  }\n\n  stats.precision = stats.truePos / (stats.truePos + stats.falsePos);\n  stats.recall = stats.truePos / (stats.truePos + stats.falseNeg);\n  stats.accuracy = (stats.trueNeg + stats.truePos) / stats.total;\n\n  stats.testSize = size;\n  stats.trainSize = data.length - size;\n\n  return {\n    avgs: avgs,\n    stats: stats,\n    sets: results,\n    misclasses: misclasses\n  };\n}\n"]}